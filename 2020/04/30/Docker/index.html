<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="AMao"><meta name="renderer" content="webkit"><meta name="copyright" content="AMao"><meta name="keywords" content="AMao's Blog"><meta name="description" content=""><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>浅谈 Docker · AMao's Blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="/img/assets/cat.png"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">AMao</div><div class="profile-signature">小菜鸡目前对一些东西的认知，希望师傅们可以帮忙纠正！</div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 70vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">AMao's Blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">浅谈 Docker</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-calendar"></i><span>2020-04-30</span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" target="_blank" rel="noopener" date-tags="计算机基础"> 计算机基础</a><a class="intro-tag fa fa-tag" href="javascript:void(0)" target="_blank" rel="noopener" date-tags="Docker"> Docker</a></span></div><div class="post-intro-read"><span> Word count: <span class="post-count">8.7k</span> | Reading time: <span class="post-count">33</span>min</span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li><p>Docker 是开源的应用容器引擎。（Goalng编写）</p>
</li>
<li><p>Docker 可以让你将所有应用软件以及它的以来打包成软件开发的标准化单元。</p>
</li>
<li><p>Docker 容器将软件以及它运行安装所需的一切文件（代码、运行时、系统工具、系统库）打包到一起，这就保证了不管是在什么样的运行环境，总是能以相同的方式运行。就好像 Java 虚拟机一样，“一次编写，到处运行（Write once, run anywhere）”，而 Docker 是“一次构建，到处运行（Build once，run anywhere）”。</p>
</li>
<li><p>概括的说</p>
<p>Docker 是为开发人员和系统管理员用于构建、发布、并运行分布式应用程序的开放式平台。该平台由 Docker 引擎（一个便携、轻巧的运行时和打包工具） 和 Docker Hub （一个共享应用程序和自动化工作流的云服务）等组成。</p>
</li>
<li><p>Docker 可以使应用程序从组件迅速组装并消除了开发、质量保证和生产环境之间的摩擦问题。这样一来，IT部门可以更快地发布，而这些应用程序不管是运行在笔记本电脑、数据中心的虚拟机，还是任何的云，其运行过程和结果都是一致的。 </p>
</li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li><p>轻量级</p>
<p>所有容器在一台机器上共享同一个操作系统内核，这样他们立即开始，并更有效地利用内存。Image 是从分层文件系统的构建，这样他们能够共享公共文件，使得磁盘使用率和 Image 的下载更加高效。</p>
</li>
<li><p>开放</p>
<p>Docker 容器是基于开发的标准，允许容器运行在主流的 Linux 发布版和 Microsoft 操作系统作为所有的基础设施。</p>
</li>
<li><p>安全</p>
<p>容器使得应用程序彼此隔离，而基础架构同时为应用程序提供了额外的保护层。 </p>
</li>
</ul>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="镜像（Image）"><a href="#镜像（Image）" class="headerlink" title="镜像（Image）"></a>镜像（Image）</h3><ul>
<li><p>Docker 镜像就是一个只读的模板。</p>
<p>例如：一个镜像可以包含一个完整的 centos 操作系统环境，里面仅安装了 Apache 或用户需要的其它应用程序。</p>
</li>
<li><p>镜像可以用来创建 Docker 容器。</p>
</li>
<li><p>Docker 提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使用。</p>
</li>
</ul>
<h3 id="容器（Container）"><a href="#容器（Container）" class="headerlink" title="容器（Container）"></a>容器（Container）</h3><ul>
<li><p>Docker 利用容器来运行应用。</p>
</li>
<li><p>容器是从镜像创建的运行实例。</p>
<p>它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。</p>
</li>
<li><p>可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。</p>
</li>
<li><p>注：镜像是只读的，容器在启动的时候创建一层可写层作为最上层。</p>
<p>仓库（Repository）**</p>
<p> 仓库是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器（Registry）混为一谈，并不严格区分。实际上，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。</p>
<p> 仓库分为公开仓库（Public）和私有仓库（Private）两种形式。</p>
</li>
</ul>
<h3 id="容器（Container）-1"><a href="#容器（Container）-1" class="headerlink" title="容器（Container）"></a>容器（Container）</h3><ul>
<li><p>Docker 利用容器来运行应用</p>
</li>
<li><p>容器是从镜像创建的运行实例</p>
<p>它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。</p>
</li>
<li><p>可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。</p>
</li>
<li><p>注：镜像是只读的，容器在启动的时候创建一层可写层作为最上层。</p>
</li>
</ul>
<h3 id="仓库（Repository）"><a href="#仓库（Repository）" class="headerlink" title="仓库（Repository）"></a>仓库（Repository）</h3><p>仓库是集中存放镜像文件的场所。</p>
<ul>
<li><p>有时候会把仓库和仓库注册服务器（Registry）混为一谈，并不严格区分。实际上，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。</p>
</li>
<li><p>仓库分为公开仓库（Public）和私有仓库（Private）两种形式。</p>
<ul>
<li><p>最大的公开仓库是 Docker Hub，存放了数量庞大的镜像供用户下载。 </p>
<p>国内的公开仓库包括 Docker Pool 等，可以提供大陆用户更稳定快速的访问。</p>
</li>
<li><p>用户也可以在本地网络内创建一个私有仓库。</p>
</li>
</ul>
<p>当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了。</p>
</li>
<li><p>注：Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。</p>
</li>
</ul>
<h2 id="Docker和虚拟机的区别"><a href="#Docker和虚拟机的区别" class="headerlink" title="Docker和虚拟机的区别"></a>Docker和虚拟机的区别</h2><h3 id="虚拟机架构"><a href="#虚拟机架构" class="headerlink" title="虚拟机架构"></a>虚拟机架构</h3><p>每个虚拟机都包括应用程序、必要的二进制文件和库以及一个完整的客户操作系统(Guest OS)，尽管它们被分离，它们共享并利用主机的硬件资源，将近需要十几个 GB 的大小。</p>
<ul>
<li><p>Hypervisor：管理程序</p>
</li>
<li><p>Infrastructure：底层结构</p>
</li>
</ul>
<h3 id="容器的架构"><a href="#容器的架构" class="headerlink" title="容器的架构"></a>容器的架构</h3><p>容器包括应用程序及其所有的依赖，但与其他容器共享内核。它们以独立的用户空间进程形式运行在主机操作系统上。</p>
<p>他们也不依赖于任何特定的基础设施，Docker 容器可以运行在任何计算机上，任何基础设施和任何云上。</p>
<p>Docker 的容器利用了 <code>LXC（Linux Container）</code>，管理利用了 <code>namespaces</code>  来做权限的控制和隔离，cgroups 来进行资源的配置，并且还通过 <code>aufs</code> 来进一步提高文件系统的资源利用率，而这些技术都不是 Docker 独创。</p>
<table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">容器</th>
<th align="center">虚拟机</th>
</tr>
</thead>
<tbody><tr>
<td align="center">启动</td>
<td align="center">秒级</td>
<td align="center">分钟级</td>
</tr>
<tr>
<td align="center">硬盘使用</td>
<td align="center">一般为MB</td>
<td align="center">一般为GB</td>
</tr>
<tr>
<td align="center">性能</td>
<td align="center">接近原生</td>
<td align="center">弱于</td>
</tr>
<tr>
<td align="center">系统支持</td>
<td align="center">单机支持上千个容器</td>
<td align="center">一般为几十个</td>
</tr>
</tbody></table>
<h3 id="LXC"><a href="#LXC" class="headerlink" title="LXC"></a>LXC</h3><p>LXC 与虚拟机的不同之处在于，它是一个操作系统级别的虚拟化环境，而不是硬件虚拟化环境。</p>
<p>他们都做同样的事情，但 LXC 是操作系统级别的虚拟化环境，虚拟环境有它自己的进程和网络空间，而不是创建一个完整成熟的虚拟机。</p>
<p>因此，一个 LXC 虚拟操作系统具有最小的资源需求，并启动只需几秒钟。</p>
<h3 id="Docker和Microservices"><a href="#Docker和Microservices" class="headerlink" title="Docker和Microservices"></a>Docker和Microservices</h3><p>Microservices（微服务） 依赖于“基础设施自动化”，而 Docker 正是“基础设施自动化”的利器。可以说 Docker 的火爆，一定程度上也带动了微服务架构的兴起，而微服务的广泛应用也促进了 Docker 繁荣。可以说两者相辅相成。</p>
<p>有关微服务的介绍，可以移步至 <a href="http://www.importnew.com/24651.html" target="_blank" rel="noopener">《简述 Microservices（微服务）》</a></p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li><p>开发更加敏捷</p>
<ul>
<li><p>Docker 让开发人员可以自由定义环境，创建和部署的应用程序更快、更容易，IT 运维人员快速应对变化也更加灵活性。</p>
</li>
<li><p>Docker 可以快速创建容器，快速迭代应用程序，并让整个过程全程可见，使团队中的其他成员更容易理解应用程序是如何创建和工作的。</p>
</li>
</ul>
</li>
<li><p>更加可控</p>
<p>Docker 使得开发人员保存从基础设施到应用的代码，帮助 IT 运维人管理拥有标准的、安全的、可扩展的操作环境。</p>
</li>
<li><p>高可移植性</p>
<p>Docker 允许自由选择，可以是从笔记本电脑到一个团队，从私人基础设施到公共云提供商。</p>
</li>
<li><p>更高效的虚拟化</p>
<p>Docker 容器的运行不需要额外的 hypervisor 支持，它是内核级的虚拟化，因此可以实现更高的性能和效率。</p>
</li>
</ul>
<h1 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h1><h2 id="修改已有的镜像"><a href="#修改已有的镜像" class="headerlink" title="修改已有的镜像"></a>修改已有的镜像</h2><p>需要启动一个容器，在容器内进行修改，并提交</p>
<ul>
<li><p>启动docker服务 （Centos）</p>
<p><code>systemctl start docker.service</code></p>
</li>
<li><p>查看已有镜像</p>
<p><code>docker images</code></p>
</li>
<li><p>启动容器并运行 <code>/bin/bash</code> 应用   </p>
<p><code>docker run -t -i Image_ID(前几位即可) /bin/bash</code></p>
<ul>
<li><p>TIPS</p>
<p>记住容器的 ID 每次启动都不同</p>
</li>
</ul>
</li>
<li><p>新建一个文件</p>
<p><code>echo &quot;hello word&quot; &gt; test.txt</code></p>
</li>
<li><p>退出容器</p>
<p><code>exit</code> </p>
</li>
<li><p>提交更新后的副本</p>
<p><code>docker commit -m &quot;提交的说明信息&quot; -a &quot;update_user_info&quot; container_id localhost:5000/centos7:tag</code></p>
<ul>
<li><p><code>-m</code></p>
<p>指定提交的说明信息，跟我们使用的版本控制工具一样；</p>
</li>
<li><p><code>-a</code></p>
<p>指定更新的用户信息</p>
</li>
<li><p>创建镜像的容器的 ID；</p>
</li>
<li><p>指定目标镜像的仓库名和 tag 信息。</p>
</li>
</ul>
<p>创建成功后会返回这个镜像的 ID 信息</p>
</li>
</ul>
<h2 id="利用Dockerfile创建镜像"><a href="#利用Dockerfile创建镜像" class="headerlink" title="利用Dockerfile创建镜像"></a>利用Dockerfile创建镜像</h2><p>使用 docker commit 来扩展一个镜像比较简单，但是不方便在一个团队中分享 </p>
<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><ul>
<li><p>概述</p>
<p>Dockerfile是一个包含用于组合映像的命令的文本文档，可以使用在命令行中调用任何命令。 Docker通过读取Dockerfile中的指令自动生成映像。</p>
<p>可以把每一层的安装、修改、构建、操作的命令都写入一个脚本 (dockerfile) ，用这个脚本来构建、定制镜像，那么之前我们提及的无法重复的问题、镜像构建透明性的问题、体积的问题都会解决</p>
</li>
<li><p>Dockerfile的基结构：</p>
<ul>
<li>基础镜像信息</li>
<li>维护者信息</li>
<li>镜像操作指令</li>
<li>容器启动时执行指令</li>
<li>注释 <code>#</code></li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># This dockerfile uses the Ubuntu image</span><br><span class="line"># VERSION 2</span><br><span class="line"># Author: docker_user</span><br><span class="line"># Command format: Instruction [arguments / command] …</span><br><span class="line"></span><br><span class="line"># 第一行必须指定基于的容器镜像</span><br><span class="line">FROM ubuntu</span><br><span class="line"></span><br><span class="line"># 维护者信息</span><br><span class="line">MAINTAINER docker_user docker_user@email.com</span><br><span class="line"></span><br><span class="line"># 镜像的操作指令，创建中运行（如安装软件包）</span><br><span class="line">RUN echo “deb http://archive.ubuntu.com/ubuntu/ raring main universe” &gt;&gt; /etc/apt/sources.list</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y nginx</span><br><span class="line">RUN echo “\ndaemon off;” &gt;&gt; /etc/nginx/nginx.conf</span><br><span class="line"></span><br><span class="line"># 容器启动时执行指令</span><br><span class="line">CMD /usr/sbin/nginx</span><br></pre></td></tr></table></figure>
</li>
<li><p>Dockerfile文件说明：</p>
<p>Docker以从上到下的顺序运行Dockerfile的指令。为了指定基本映像，第一条指令必须是FROM。</p>
<p>可以在Docker文件中使用指令</p>
<ul>
<li><p>ADD</p>
<p>复制本地文件到镜像</p>
</li>
<li><p>RUN</p>
<p>镜像创建中执行的命令</p>
</li>
<li><p>CMD</p>
<p>描述容器启动后运行的程序（命令）</p>
</li>
<li><p>FROM</p>
<p>指定基于的容器镜像</p>
</li>
<li><p>EXPOSE</p>
<p>指定向外部开放端口</p>
<p><code>EXPOSE port</code></p>
</li>
<li><p>ENV</p>
<p>定义镜像的环境变量</p>
</li>
</ul>
</li>
</ul>
<h3 id="Dockerfile-创建镜像"><a href="#Dockerfile-创建镜像" class="headerlink" title="Dockerfile 创建镜像"></a>Dockerfile 创建镜像</h3><ul>
<li><p>命令格式</p>
<p><code>docker build [options] Path | URL | .</code></p>
</li>
<li><p>eg.</p>
<p><code>docker build -t=&quot;myimage/centos7:v3&quot; .</code></p>
<ul>
<li><p><code>-t</code> </p>
<p>添加 tag，指定新的镜像的用户信息</p>
</li>
</ul>
</li>
<li><p>创建过程</p>
<p>根据进程操作的输出信息</p>
<ul>
<li><p>首先上传 Dockerfile 内容，因为所有的操作都要依据 Dockerfile 来进行。</p>
</li>
<li><p>Dockfile 中的指令被一条一条的执行</p>
<p>每一步都创建了一个新的容器，在容器中执行指令并提交修改（就跟之前介绍过的 docker commit 一样）。</p>
</li>
<li><p>当所有的指令都执行完毕之后，返回了最终的镜像 id。</p>
<p>所有的中间步骤所产生的容器都被删除和清理了</p>
</li>
</ul>
</li>
<li><p>TIPS：</p>
<p>一个镜像不能超过 127 层</p>
</li>
</ul>
<h4 id="镜像构建上下文"><a href="#镜像构建上下文" class="headerlink" title="镜像构建上下文"></a>镜像构建上下文</h4><ul>
<li><p>在上面的构建命令中，会看到在 <code>docker build</code> 命令的结尾处有一个 <code>.</code>，表示当前目录，而Dockerfile就在当前目录，因此不少初学者以为这个就是指定Dockerfile所在路径，这么理解其实是不准确的。对应上面的命令格式，这其实是在指定上下文路径。</p>
</li>
<li><p>Docker在运行时分为 Docker 引擎和客户端工具。</p>
<ul>
<li>Docker引擎提供了一组REST API，被称为 <code>Docker Remote API</code></li>
<li>Docker命令这样的客户端工具，则是通过<code>Docker Remote API</code> 来与 Docker 引擎进行交互，从而完成各种功能的</li>
</ul>
<p>虽然表面上是在本机上完成各种Docker功能，但是实际上是通过 <code>Docker Remote API</code> 与Docker引擎交互，在Docker引擎中完成的各种功能。</p>
<p>正是因为这种C/S设计，使得我们操作远程服务器的 Docker 引擎变得轻而易举。</p>
</li>
<li><p>当我们进行镜像构建时，并非所有定制都会通过RUN命令完成，经常我们需要将一些本地文件复制至镜像，比如通过COPY指令、ADD指令等。</p>
<p>可是镜像的构建是在Docker引擎中完成的，该如何将本地的文件上传到Docker引擎中呢？</p>
<p>这就引入上下文概念，当镜像构建时会指定上下文路径，<code>docker build</code> 得知这个路径时，会将该路径下的所有内容打包，上传给Docker引擎。Docker引擎接收到这个上下文包之后，展开就会获得构建镜像的一切所需文件。</p>
</li>
<li><p>Dockerfile 中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY ./package.json /app/</span><br></pre></td></tr></table></figure>

<p>命令指定上下文路径为：<code>.</code> ，则将 <code>当前目录（执行命令）/package.json</code> 复制到镜像中的 <code>/app/</code> 目录下</p>
</li>
</ul>
<h4 id="Dockerfile-文件命名"><a href="#Dockerfile-文件命名" class="headerlink" title="Dockerfile 文件命名"></a>Dockerfile 文件命名</h4><p>Dockerfile的文件名并不要求必须是Dockerfile，也并不要求必须将Dockerfile文件置于上下文目录当中，可以添加 <code>-f</code> 参数来指定 Dockerfile 的文件</p>
<h2 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h2><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><ul>
<li><p>命令</p>
<p><code>docker images</code></p>
</li>
</ul>
<h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><ul>
<li><p>命令（在镜像目录下）</p>
<p><code>cat ubuntu-14.04.tar.gz | docker import - ubuntu:14.04</code></p>
</li>
<li><p>导出的本地文件中再导入到本地镜像库</p>
<p><code>docker load --input package_name.tar</code></p>
</li>
</ul>
<h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><ul>
<li><p>命令</p>
<p><code>docker save -o package_name.tar ubuntu:tag</code></p>
</li>
</ul>
<h3 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h3><ul>
<li><p>命令</p>
<p><code>docker rmi Image_id/name</code></p>
</li>
<li><p>TIPS</p>
<p>在删除镜像之前要先用 <code>docker rm</code>  删掉依赖于这个镜像的所有容器</p>
</li>
<li><p>清理正在运行的容器</p>
<p><code>docker stop $(docker ps -a -q)</code></p>
<p><code>docker rm $(docker ps -a -q)</code></p>
</li>
</ul>
<h1 id="使用镜像创建容器"><a href="#使用镜像创建容器" class="headerlink" title="使用镜像创建容器"></a>使用镜像创建容器</h1><ul>
<li><p>命令</p>
<p><code>docker run -t -i Image_ID /bin/bash</code></p>
<ul>
<li><p><code>-t</code> </p>
<p>让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上</p>
</li>
<li><p><code>-i</code></p>
<p>让容器的标准输入保持打开</p>
</li>
<li><p><code>-d</code> </p>
<p>后台运行</p>
</li>
</ul>
</li>
</ul>
<h1 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h1><ul>
<li><p>查看</p>
<p><code>docker ps -a</code></p>
</li>
<li><p>启动</p>
<p><code>docker start Container_ID</code></p>
</li>
<li><p>停止</p>
<p><code>docker stop Container_ID</code></p>
</li>
<li><h3 id="查看输出信息"><a href="#查看输出信息" class="headerlink" title="查看输出信息"></a>查看输出信息</h3><p><code>docker logs Container_ID</code></p>
</li>
<li><p>退出</p>
<p><code>exit</code></p>
<p><code>Ctrl + C</code></p>
</li>
<li><h3 id="进入"><a href="#进入" class="headerlink" title="进入"></a>进入</h3><ul>
<li><p><code>docker exec -it container_ID sh</code></p>
</li>
<li><p><code>docker attach container_ID</code> </p>
<p>当多个窗口同时 attach 到同一个容器的时候，所有窗口都会同步显示</p>
<p>当某个窗口因命令阻塞时，其他窗口也无法执行操作了</p>
</li>
<li><p>nsenter</p>
<ul>
<li><p>安装</p>
<p>大部分Linux发行版本都有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line">curl https://www.kernel.org/pub/linux/utils/util-linux/v2.24/util-linux-2.24.tar.gz |tar -zxf-</span><br><span class="line">cd util-linux-2.24</span><br><span class="line">./configure --without-ncurses</span><br><span class="line">make nsenter</span><br><span class="line">cp nsenter /usr/lacal/bin</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用</p>
<p>为了连接到容器，需要找到容器的第一个进程的 PID</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PID=$(docker inspect --format= &quot;&#123;&#123;.State.Pid&#125;&#125;&quot; container_ID)</span><br><span class="line">nsenter --target $PID --mount --uts --ips --net -pid</span><br></pre></td></tr></table></figure>

<p>也可以编写自动脚本</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>删除</p>
<p><code>docker rm Container_ID</code></p>
</li>
<li><p>删除正在运行的容器</p>
<p><code>docker rm -f COntainer_ID</code></p>
<p>Docker 会发送 SIGKILL 信号给容器  </p>
</li>
</ul>
<h1 id="容器与主机之间的文件操作"><a href="#容器与主机之间的文件操作" class="headerlink" title="容器与主机之间的文件操作"></a>容器与主机之间的文件操作</h1><ul>
<li><p>复制文件到容器</p>
<p><code>docker cp /xx/xx/xxx.xxx Container_ID:/xxx/xxx/xxx.xx</code></p>
</li>
</ul>
<h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，可以使用 YML 文件来配置应用程序需要的所有服务</p>
<ul>
<li><p>Compose 使用的三个步骤：</p>
<ul>
<li>使用 Dockerfile 定义应用程序的环境</li>
<li>使用 <code>docker-compose.yml</code>  定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。</li>
<li>最后，执行 docker-compose up 命令来启动并运行整个应用程序。</li>
</ul>
</li>
<li><p>示例</p>
<ul>
<li><p>Dockerfile</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 从 Python 3.7 映像开始构建镜像</span><br><span class="line">FROM python:3.7-alpine</span><br><span class="line"># 将工作目录设置为 /code</span><br><span class="line">WORKDIR /code</span><br><span class="line"># 设置 flask 命令使用的环境变量</span><br><span class="line">ENV FLASK_APP app.py</span><br><span class="line">ENV FLASK_RUN_HOST 0.0.0.0</span><br><span class="line"># 安装 gcc，以便诸如 MarkupSafe 和 SQLAlchemy 之类的 Python 包可以编译加速。</span><br><span class="line">RUN apk add --no-cache gcc musl-dev linux-headers</span><br><span class="line">COPY requirements.txt requirements.txt</span><br><span class="line">RUN pip install -r requirements.txt</span><br><span class="line">COPY . .</span><br><span class="line"># 容器提供默认的执行命令为：flask run</span><br><span class="line">CMD [&quot;flask&quot;, &quot;run&quot;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>docker-compose.yml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># yaml 配置</span><br><span class="line">version: &apos;3&apos;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">     - &quot;5000:5000&quot;</span><br><span class="line">  redis:</span><br><span class="line">    image: &quot;redis:alpine&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动应用程序</p>
<p><code>docker-compose up</code></p>
<p>加上 <code>-d</code> 可以后台运行</p>
</li>
</ul>
</li>
</ul>
<h2 id="yml-配置指令参考"><a href="#yml-配置指令参考" class="headerlink" title="yml 配置指令参考"></a>yml 配置指令参考</h2><ul>
<li><p>version</p>
<p>指定本 yml 依从的 compose 哪个版本制定的。</p>
</li>
<li><p>build</p>
<p>指定为构建镜像上下文路径：</p>
<p>例如 webapp 服务，指定为从上下文路径 <code>./dir/Dockerfile</code> 所构建的镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  webapp:</span><br><span class="line">    build: ./dir</span><br></pre></td></tr></table></figure>

<p>或者，作为具有在上下文指定的路径的对象，以及可选的 Dockerfile 和 args：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  webapp:</span><br><span class="line">    build:</span><br><span class="line">      context: ./dir</span><br><span class="line">      dockerfile: Dockerfile-alternate</span><br><span class="line">      args:</span><br><span class="line">        buildno: 1</span><br><span class="line">      labels:</span><br><span class="line">        - &quot;com.example.description=Accounting webapp&quot;</span><br><span class="line">        - &quot;com.example.department=Finance&quot;</span><br><span class="line">        - &quot;com.example.label-with-empty-value&quot;</span><br><span class="line">      target: prod</span><br></pre></td></tr></table></figure>

<ul>
<li>context：上下文路径。</li>
<li>dockerfile：指定构建镜像的 Dockerfile 文件名。</li>
<li>args：添加构建参数，这是只能在构建过程中访问的环境变量。</li>
<li>labels：设置构建镜像的标签。</li>
<li>target：多层构建，可以指定构建哪一层。</li>
</ul>
</li>
<li><p>cap_add，cap_drop</p>
<p>添加或删除容器拥有的宿主机的内核功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cap_add:</span><br><span class="line">  - ALL # 开启全部权限</span><br><span class="line"></span><br><span class="line">cap_drop:</span><br><span class="line">  - SYS_PTRACE # 关闭 ptrace权限</span><br></pre></td></tr></table></figure>
</li>
<li><p>cgroup_parent</p>
<p>为容器指定父 cgroup 组，意味着将继承该组的资源限制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cgroup_parent: m-executor-abcd</span><br></pre></td></tr></table></figure>
</li>
<li><p>command</p>
<p>覆盖容器启动的默认命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command: [&quot;bundle&quot;, &quot;exec&quot;, &quot;thin&quot;, &quot;-p&quot;, &quot;3000&quot;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>container_name</p>
<p>指定自定义容器名称，而不是生成的默认名称。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container_name: my-web-container</span><br></pre></td></tr></table></figure>
</li>
<li><p>depeds_on</p>
<p>设置依赖关系。</p>
<ul>
<li>docker-compose up ：以依赖性顺序启动服务。在以下示例中，先启动 db 和 redis ，才会启动 web。</li>
<li>docker-compose up SERVICE ：自动包含 SERVICE 的依赖项。在以下示例中，docker-compose up web 还将创建并启动 db 和 redis。</li>
<li>docker-compose stop ：按依赖关系顺序停止服务。在以下示例中，web 在 db 和 redis 之前停止。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">      - redis</span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br></pre></td></tr></table></figure>

<p>注意：web 服务不会等待 redis db 完全启动 之后才启动。</p>
</li>
<li><p>deploy</p>
<p>指定与服务的部署和运行有关的配置。只在 swarm 模式下才会有用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  redis:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    deploy:</span><br><span class="line">      mode：replicated</span><br><span class="line">      replicas: 6</span><br><span class="line">      endpoint_mode: dnsrr</span><br><span class="line">      labels: </span><br><span class="line">        description: &quot;This redis service label&quot;</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &apos;0.50&apos;</span><br><span class="line">          memory: 50M</span><br><span class="line">        reservations:</span><br><span class="line">          cpus: &apos;0.25&apos;</span><br><span class="line">          memory: 20M</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">        delay: 5s</span><br><span class="line">        max_attempts: 3</span><br><span class="line">        window: 120s</span><br></pre></td></tr></table></figure>

<p>可以选参数：</p>
<ul>
<li><p>endpoint_mode：访问集群服务的方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">endpoint_mode: vip </span><br><span class="line"># Docker 集群服务一个对外的虚拟 ip。所有的请求都会通过这个虚拟 ip 到达集群服务内部的机器。</span><br><span class="line">endpoint_mode: dnsrr</span><br><span class="line"># DNS 轮询（DNSRR）。所有的请求会自动轮询获取到集群 ip 列表中的一个 ip 地址。</span><br></pre></td></tr></table></figure>
</li>
<li><p>labels：在服务上设置标签。可以用容器上的 labels（跟 deploy 同级的配置） 覆盖 deploy 下的 labels。</p>
</li>
<li><p>mode：指定服务提供的模式。</p>
<ul>
<li>replicated：复制服务，复制指定服务到集群的机器上。</li>
<li>global：全局服务，服务将部署至集群的每个节点。</li>
</ul>
</li>
<li><p>replicas：mode为 replicated 时，需要使用此参数配置具体运行的节点数量。</p>
</li>
<li><p>resources：配置服务器资源使用的限制，例如上例子，配置 redis 集群运行需要的 cpu 的百分比 和 内存的占用。避免占用资源过高出现异常。</p>
</li>
<li><p>restart_policy：配置如何在退出容器时重新启动容器。</p>
<ul>
<li>condition：可选 none，on-failure 或者 any（默认值：any）。</li>
<li>delay：设置多久之后重启（默认值：0）。</li>
<li>max_attempts：尝试重新启动容器的次数，超出次数，则不再尝试（默认值：一直重试）。</li>
<li>window：设置容器重启超时时间（默认值：0）。</li>
</ul>
</li>
<li><p>rollback_config：配置在更新失败的情况下应如何回滚服务。</p>
<ul>
<li>parallelism：一次要回滚的容器数。如果设置为0，则所有容器将同时回滚。</li>
<li>delay：每个容器组回滚之间等待的时间（默认为0s）。</li>
<li>failure_action：如果回滚失败，该怎么办。其中一个 continue 或者 pause（默认pause）。</li>
<li>monitor：每个容器更新后，持续观察是否失败了的时间 (ns|us|ms|s|m|h)（默认为0s）。</li>
<li>max_failure_ratio：在回滚期间可以容忍的故障率（默认为0）。</li>
<li>order：回滚期间的操作顺序。其中一个 stop-first（串行回滚），或者 start-first（并行回滚）（默认 stop-first ）。</li>
</ul>
</li>
<li><p>update_config：配置应如何更新服务，对于配置滚动更新很有用。</p>
<ul>
<li>parallelism：一次更新的容器数。</li>
<li>delay：在更新一组容器之间等待的时间。</li>
<li>failure_action：如果更新失败，该怎么办。其中一个 continue，rollback 或者pause （默认：pause）。</li>
<li>monitor：每个容器更新后，持续观察是否失败了的时间 (ns|us|ms|s|m|h)（默认为0s）。</li>
<li>max_failure_ratio：在更新过程中可以容忍的故障率。</li>
<li>order：回滚期间的操作顺序。其中一个 stop-first（串行回滚），或者 start-first（并行回滚）（默认stop-first）。</li>
</ul>
<p>注：仅支持 V3.4 及更高版本。</p>
</li>
</ul>
</li>
<li><p>devices</p>
<p>指定设备映射列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">devices:</span><br><span class="line">  - &quot;/dev/ttyUSB0:/dev/ttyUSB0&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>dns</p>
<p>自定义 DNS 服务器，可以是单个值或列表的多个值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dns: 8.8.8.8</span><br><span class="line"></span><br><span class="line">dns:</span><br><span class="line">  - 8.8.8.8</span><br><span class="line">  - 9.9.9.9</span><br></pre></td></tr></table></figure>
</li>
<li><p>dns_search</p>
<p>自定义 DNS 搜索域。可以是单个值或列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dns_search: example.com</span><br><span class="line"></span><br><span class="line">dns_search:</span><br><span class="line">  - dc1.example.com</span><br><span class="line">  - dc2.example.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>entrypoint</p>
<p>覆盖容器默认的 entrypoint</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entrypoint: /code/entrypoint.sh</span><br></pre></td></tr></table></figure>

<p>也可以是以下格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">entrypoint:</span><br><span class="line">    - php</span><br><span class="line">    - -d</span><br><span class="line">    - zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20100525/xdebug.so</span><br><span class="line">    - -d</span><br><span class="line">    - memory_limit=-1</span><br><span class="line">    - vendor/bin/phpunit</span><br></pre></td></tr></table></figure>
</li>
<li><p>env_file</p>
<p>从文件添加环境变量。可以是单个值或列表的多个值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env_file: .env</span><br></pre></td></tr></table></figure>

<p>也可以是列表格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">env_file:</span><br><span class="line">  - ./common.env</span><br><span class="line">  - ./apps/web.env</span><br><span class="line">  - /opt/secrets.env</span><br></pre></td></tr></table></figure>
</li>
<li><p>environment</p>
<p>添加环境变量。您可以使用数组或字典、任何布尔值，布尔值需要用引号引起来，以确保 YML 解析器不会将其转换为 True 或 False。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">environment:</span><br><span class="line">  RACK_ENV: development</span><br><span class="line">  SHOW: &apos;true&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>expose</p>
<p>暴露端口，但不映射到宿主机，只被连接的服务访问。</p>
<p>仅可以指定内部端口为参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expose:</span><br><span class="line"> - &quot;3000&quot;</span><br><span class="line"> - &quot;8000&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>extra_hosts</p>
<p>添加主机名映射。类似 docker client –add-host。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extra_hosts:</span><br><span class="line"> - &quot;somehost:162.242.195.82&quot;</span><br><span class="line"> - &quot;otherhost:50.31.209.229&quot;</span><br></pre></td></tr></table></figure>

<p>以上会在此服务的内部容器中 /etc/hosts 创建一个具有 ip 地址和主机名的映射关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">162.242.195.82  somehost</span><br><span class="line">50.31.209.229   otherhost</span><br></pre></td></tr></table></figure>
</li>
<li><p>healthcheck</p>
<p>用于检测 docker 服务是否健康运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">healthcheck:</span><br><span class="line">  test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;] # 设置检测程序</span><br><span class="line">  interval: 1m30s # 设置检测间隔</span><br><span class="line">  timeout: 10s # 设置检测超时时间</span><br><span class="line">  retries: 3 # 设置重试次数</span><br><span class="line">  start_period: 40s # 启动后，多少秒开始启动检测程序</span><br></pre></td></tr></table></figure>
</li>
<li><p>image</p>
<p>指定容器运行的镜像。以下格式都可以：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">image: redis</span><br><span class="line">image: ubuntu:14.04</span><br><span class="line">image: tutum/influxdb</span><br><span class="line">image: example-registry.com:4000/postgresql</span><br><span class="line">image: a4bc65fd # 镜像id</span><br></pre></td></tr></table></figure>
</li>
<li><p>logging</p>
<p>服务的日志记录配置。</p>
<p>driver：指定服务容器的日志记录驱动程序，默认值为json-file。有以下三个选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driver: &quot;json-file&quot;</span><br><span class="line">driver: &quot;syslog&quot;</span><br><span class="line">driver: &quot;none&quot;</span><br></pre></td></tr></table></figure>

<p>仅在 json-file 驱动程序下，可以使用以下参数，限制日志得数量和大小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">  driver: json-file</span><br><span class="line">  options:</span><br><span class="line">    max-size: &quot;200k&quot; # 单个文件大小为200k</span><br><span class="line">    max-file: &quot;10&quot; # 最多10个文件</span><br></pre></td></tr></table></figure>

<p>当达到文件限制上限，会自动删除旧得文件。</p>
<p>syslog 驱动程序下，可以使用 syslog-address 指定日志接收地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">  driver: syslog</span><br><span class="line">  options:</span><br><span class="line">    syslog-address: &quot;tcp://192.168.0.42:123&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>network_mode</p>
<p>设置网络模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">network_mode: &quot;bridge&quot;</span><br><span class="line">network_mode: &quot;host&quot;</span><br><span class="line">network_mode: &quot;none&quot;</span><br><span class="line">network_mode: &quot;service:[service name]&quot;</span><br><span class="line">network_mode: &quot;container:[container name/id]&quot;</span><br></pre></td></tr></table></figure>

<p>networks</p>
<p>配置容器连接的网络，引用顶级 networks 下的条目 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">services:</span><br><span class="line">  some-service:</span><br><span class="line">    networks:</span><br><span class="line">      some-network:</span><br><span class="line">        aliases:</span><br><span class="line">         - alias1</span><br><span class="line">      other-network:</span><br><span class="line">        aliases:</span><br><span class="line">         - alias2</span><br><span class="line">networks:</span><br><span class="line">  some-network:</span><br><span class="line">    # Use a custom driver</span><br><span class="line">    driver: custom-driver-1</span><br><span class="line">  other-network:</span><br><span class="line">    # Use a custom driver which takes special options</span><br><span class="line">    driver: custom-driver-2</span><br></pre></td></tr></table></figure>

<ul>
<li>aliases ：同一网络上的其他容器可以使用服务名称或此别名来连接到对应容器的服务。</li>
</ul>
</li>
<li><p>restart</p>
<ul>
<li>no：是默认的重启策略，在任何情况下都不会重启容器。</li>
<li>always：容器总是重新启动。</li>
<li>on-failure：在容器非正常退出时（退出状态非0），才会重启容器。</li>
<li>unless-stopped：在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">restart: &quot;no&quot;</span><br><span class="line">restart: always</span><br><span class="line">restart: on-failure</span><br><span class="line">restart: unless-stopped</span><br></pre></td></tr></table></figure>

<p>注：swarm 集群模式，请改用 restart_policy。</p>
</li>
<li><p>secrets</p>
<p>存储敏感数据，例如密码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.1&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">mysql:</span><br><span class="line">  image: mysql</span><br><span class="line">  environment:</span><br><span class="line">    MYSQL_ROOT_PASSWORD_FILE: /run/secrets/my_secret</span><br><span class="line">  secrets:</span><br><span class="line">    - my_secret</span><br><span class="line"></span><br><span class="line">secrets:</span><br><span class="line">  my_secret:</span><br><span class="line">    file: ./my_secret.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>security_opt</p>
<p>修改容器默认的 schema 标签。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">security-opt：</span><br><span class="line">  - label:user:USER   # 设置容器的用户标签</span><br><span class="line">  - label:role:ROLE   # 设置容器的角色标签</span><br><span class="line">  - label:type:TYPE   # 设置容器的安全策略标签</span><br><span class="line">  - label:level:LEVEL  # 设置容器的安全等级标签</span><br></pre></td></tr></table></figure>
</li>
<li><p>stop_grace_period</p>
<p>指定在容器无法处理 SIGTERM (或者任何 stop_signal 的信号)，等待多久后发送 SIGKILL 信号关闭容器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stop_grace_period: 1s # 等待 1 秒</span><br><span class="line">stop_grace_period: 1m30s # 等待 1 分 30 秒</span><br></pre></td></tr></table></figure>

<p>默认的等待时间是 10 秒。</p>
</li>
<li><p>stop_signal</p>
<p>设置停止容器的替代信号。默认情况下使用 SIGTERM 。</p>
<p>以下示例，使用 SIGUSR1 替代信号 SIGTERM 来停止容器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop_signal: SIGUSR1</span><br></pre></td></tr></table></figure>
</li>
<li><p>sysctls</p>
<p>设置容器中的内核参数，可以使用数组或字典格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sysctls:</span><br><span class="line">  net.core.somaxconn: 1024</span><br><span class="line">  net.ipv4.tcp_syncookies: 0</span><br><span class="line"></span><br><span class="line">sysctls:</span><br><span class="line">  - net.core.somaxconn=1024</span><br><span class="line">  - net.ipv4.tcp_syncookies=0</span><br></pre></td></tr></table></figure>
</li>
<li><p>tmpfs</p>
<p>在容器内安装一个临时文件系统。可以是单个值或列表的多个值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tmpfs: /run</span><br><span class="line"></span><br><span class="line">tmpfs:</span><br><span class="line">  - /run</span><br><span class="line">  - /tmp</span><br></pre></td></tr></table></figure>
</li>
<li><p>ulimits</p>
<p>覆盖容器默认的 ulimit。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ulimits:</span><br><span class="line">  nproc: 65535</span><br><span class="line">  nofile:</span><br><span class="line">    soft: 20000</span><br><span class="line">    hard: 40000</span><br></pre></td></tr></table></figure>
</li>
<li><p>volumes</p>
<p>将主机的数据卷或着文件挂载到容器里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  db:</span><br><span class="line">    image: postgres:latest</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/localhost/postgres.sock:/var/run/postgres/postgres.sock&quot;</span><br><span class="line">      - &quot;/localhost/data:/var/lib/postgresql/data&quot;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h1><ul>
<li><p>概述</p>
<p>Docker镜像是由多个文件系统（只读层）叠加而成。</p>
<p>当我们启动一个容器的时候，Docker会加载只读镜像层并在其上（镜像栈顶部）添加一个读写层。</p>
<p>如果运行中的容器修改了现有的一个已经存在的文件，那该文件将会从读写层下面的只读层复制到读写层，该文件的只读版本仍然存在，只是已经被读写层中该文件的副本所隐藏。</p>
<p>当删除Docker容器，并通过该镜像重新启动时，之前的更改将会丢失。在Docker中，只读层及在顶部的读写层的组合被称为 Union File System（联合文件系统）</p>
<p>为了能够保存（持久化）数据以及共享容器间的数据，Docker提出了 Volume 的概念。简单来说，Volume就是目录或者文件，它可以绕过默认的联合文件系统，而以正常的文件或者目录的形式存在于宿主机上。</p>
</li>
<li><p>在容器中管理数据主要有两种方式：</p>
<ul>
<li><h3 id="数据卷（Data-volumes）"><a href="#数据卷（Data-volumes）" class="headerlink" title="数据卷（Data volumes）"></a>数据卷（Data volumes）</h3><p>数据卷是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，</p>
<p>可以提供很多有用的特性：</p>
<ul>
<li><p>数据卷可以在容器之间共享和重用</p>
</li>
<li><p>对数据卷的修改会立马生效</p>
</li>
<li><p>对数据卷的更新，不会影响镜像</p>
</li>
<li><p>卷会一直存在，即使容器被删除</p>
</li>
</ul>
<p>数据卷的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的数据卷</p>
</li>
<li><h3 id="数据卷容器（Data-volume-containers）"><a href="#数据卷容器（Data-volume-containers）" class="headerlink" title="数据卷容器（Data volume containers）"></a>数据卷容器（Data volume containers）</h3><p>如果有一些持续更新的数据需要在容器之间共享，最好创建数据卷容器。</p>
<p>数据卷容器，其实就是一个正常的容器，专门用来提供数据卷供其它容器挂载的</p>
</li>
</ul>
</li>
</ul>
<h2 id="数据卷的操作"><a href="#数据卷的操作" class="headerlink" title="数据卷的操作"></a>数据卷的操作</h2><ul>
<li><p>创建一个数据卷</p>
<p><code>docker volume create my-vol</code></p>
</li>
<li><p>查看数据卷</p>
<p><code>docker volume ls</code></p>
<ul>
<li><p>查看指定数据卷</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume inspect volume_name</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;my-vol&quot;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>启动一个挂载数据卷的容器</p>
<p>在用 <code>docker run</code> 命令的时候，使用 <code>--mount</code> 标记来将 <code>数据卷</code> 挂载到容器里</p>
<p>在一次 <code>docker run</code> 中可以挂载多个数据卷</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    # -v my-vol:/wepapp \</span><br><span class="line">    --mount source=my-vol,target=/webapp \</span><br><span class="line">    training/webapp \</span><br><span class="line">    python app.py</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看数据卷的具体信息</p>
<p><code>docker inspect web</code></p>
</li>
<li><p>删除数据卷</p>
<p><code>docker volume rm volume_name</code></p>
<p>数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷</p>
<ul>
<li><p>删除容器的时候使用  <code>docker rm -v</code>  删除数据卷</p>
</li>
<li><p>清理无主的数据卷，避免占据空间</p>
<p><code>docker volume prune</code></p>
</li>
</ul>
</li>
<li><p>在用 docker run 命令的时候，使用 <code>-v</code> 标记来创建一个数据卷并挂载到容器里</p>
<p>在一次 run 中多次使用可以挂载多个数据卷</p>
<p>也可以在 Dockerfile 中使用 VOLUME 来添加一个或者多个新的卷到由该镜像创建的任意容器</p>
<ul>
<li><p>加载一个数据卷到容器的 /webapp 目录，命令</p>
<p><code>docker run -d -P --name web -v /webapp training/webapp python app.py</code></p>
<p>创建一个 web 容器，并加载一个数据卷到容器的 /webapp 目录</p>
<ul>
<li><code>-d</code>：后台运行</li>
<li><code>-P</code>：自动映射任意网络端口到我们Docker主机上介于49000到49900之间的随机高位端口</li>
<li><code>--name</code>：启动的时候使用了 –name 命名这个container为 web</li>
<li><code>-v</code>： 标记数据卷</li>
</ul>
</li>
<li><p>挂载一个主机目录作为数据卷</p>
<p>交互模式：<code>docker run -it -v /home/dock/Downloads:/usr/Downloads ubuntu64 /bin/bash</code></p>
<p>后台运行：<code>docker run -d -v /home/dock/Downloads:/usr/Downloads --name ubuntu1 ubuntu64</code></p>
<p>加载主机的 <code>/home/dock/Downloads</code> 目录到容器的<code>/usr/Downloads</code> 目录</p>
<ul>
<li>本地目录的路径必须是绝对路径，如果目录不存在 Docker 会自动创建</li>
<li>Dockerfile 中不支持这种用法，这是因为 Dockerfile 是为了移植和分享用的。然而，不同操作系统的路径格式不一样，所以目前还不能支持</li>
</ul>
</li>
</ul>
</li>
<li><p>Docker 挂载数据卷的默认权限是读写，用户也可以通过 <code>:ro</code> 指定为只读</p>
<p><code>docker run -d -P -name web -v /src/webapp:/opt/webapp:ro training/webapp python app.py</code></p>
</li>
</ul>
<h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p>如果用户需要在多个容器之间共享一些持续更新的数据，最简单的方式是使用数据卷容器。数据卷容器也是一个容器，但是它的目的是专门用来提供数据卷供其他容器挂载。</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul>
<li><p>创建一个命名的数据卷容器 dbdata </p>
<p><code>docker run -d -v /data --name dbdata training/postgres echo Data-only container for postgres</code></p>
</li>
<li><p>在其他容器中使用 –volumes-from 来挂载 dbdata 容器中的数据卷。</p>
<p><code>docker run -d --volumes-from dbdata --name db1 training/postgres</code></p>
<p><code>docker run -d --volumes-from dbdata --name db2 training/postgres</code></p>
<p>三个容器任何一方在该目录下的写入，其他容器都可以看到</p>
<p>可以多次使用–volumes-from参数来从多个容器挂载多个数据卷</p>
</li>
<li><p>也可以从其他已经挂载了容器卷的容器来挂载数据卷：</p>
<p>链式dbdata -&gt; db1 -&gt; db3</p>
<p><code>docker run -d --name db3 --volumes-from db1 training/postgres</code></p>
</li>
<li><p>把所有mount volumes的container都移除掉（包括初始化的那个 dbdata container）， volume才会被移除掉。通过这个属性可以方便的升级数据或者在不同container间迁移数据。</p>
</li>
<li><p>TIPS：使用 –volumes-from 参数所挂载数据卷的容器自己并不需要保持在运行状态</p>
</li>
</ul>
<h3 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h3><ul>
<li><p>备份</p>
<ul>
<li><p>启动数据容器</p>
<p><code>docker run -d -v /dbdata --name dbdata training/postgres echo Data-only container for postgres</code></p>
</li>
<li><p>本地主机挂载当前目录到容器的 /backup 目录</p>
<p><code>docker run --volumes-from dbdata -v$(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata</code></p>
<p>容器启动后，将容器中的<code>/backup/backup.tar</code> 备份到 <code>/dbdata</code></p>
<p><code>$(pwd)</code> 是当前目录</p>
</li>
</ul>
</li>
<li><p>恢复</p>
<ul>
<li><p>首先</p>
</li>
<li><p>创建一个带有数据卷的容器 dbdata2</p>
<p><code>docker run -v /dbdata --name dbdata2 ubuntu /bin/bash</code></p>
</li>
<li><p>然后创建另一个容器，挂载 dbdata2 的容器，并使用 tar 解压备份文件到挂载的容器卷中</p>
<p><code>docker run --volumes-from dbdata2 -v $(pwd):/backup basybox tar xvf /backup/backup.tar</code></p>
</li>
</ul>
</li>
</ul>
<h1 id="网络使用"><a href="#网络使用" class="headerlink" title="网络使用"></a>网络使用</h1><p>Docker 允许通过外部访问容器或容器互联的方式来提供网络服务。</p>
<p>当docker启动时，它会在宿主机器上创建一个名为docker0的虚拟网络接口。它会从RFC 1918定义的私有地址中随机选择一个主机不用的地址和子网掩码，并将它分配给docker0</p>
<h2 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h2><ul>
<li><p>随机映射</p>
<p>使用 <code>-P</code> 标记时，Docker 会随机映射一个 49000~49900 的端口到内部容器开放的网络端</p>
<p><code>docker run -d -P training/webapp python app.py</code></p>
</li>
<li><p>指定映射</p>
<p><code>-p</code>则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器</p>
<ul>
<li><p>格式</p>
<ul>
<li><p><code>ip:host_port:container_port</code></p>
</li>
<li><p><code>ip::container_port</code></p>
<p>主机端口随机，指定 IP 和容器端口</p>
</li>
<li><p><code>host_port:container_port</code></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>查看映射端口配置</p>
<ul>
<li><code>docker port Container_ID</code></li>
<li><code>docker port Container_ID Port_ID</code></li>
</ul>
</li>
</ul>
<h3 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h3><p>容器的连接（linking）系统是除了端口映射外，另一种跟容器中应用交互的方式。</p>
<p>该系统会在源和接收容器之间创建一个隧道，接收容器可以看到源容器指定的信息</p>
<ul>
<li><p>自定义容器命名</p>
<p>连接系统依据容器的名称来执行。因此，首先需要自定义一个好记的容器命名。</p>
<p>虽然当创建容器的时候，系统默认会分配一个名字，使用 <code>--name</code> 标记可以为容器自定义命名</p>
<p><code>docker run -d --name Database training/postgres</code></p>
<p>在启动 <code>Database</code> 容器的时候并没有使用 -p 和 -P 标记，从而避免了暴露数据库端口到外部网络上</p>
</li>
<li><p><code>--link</code> 参数可以让容器之间安全的进行交互</p>
<p><code>docker run -d -P --name Web --link Database:alias training/webapp python app.py</code></p>
<ul>
<li>–link 参数的格式：<code>--link name:alias</code><ul>
<li><code>name</code> 是要链接的容器的名称</li>
<li><code>alias</code> 是这个连接的别名</li>
</ul>
</li>
</ul>
</li>
<li><p>Docker 通过 2 种方式为容器公开连接信息。</p>
<ul>
<li><p>环境变量</p>
<p>命令：<code>env</code></p>
<p><code>DATABASE_</code> 开头的环境变量是供 web 容器连接 db 容器使用，前缀采用大写的连接别名</p>
</li>
<li><p>更新 /etc/hosts 文件</p>
<p>Docker 还添加 host 信息到父容器（这里指Web）的 <code>/etc/hosts</code> 的文件</p>
<p>命令：<code>cat /etc/hosts</code></p>
<p>容器的ID作为主机名</p>
<ul>
<li><p>测试连通性</p>
<p><code>ping Container_Name</code>   会解析成具体的IP</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="管理工具"><a href="#管理工具" class="headerlink" title="管理工具"></a>管理工具</h1><h2 id="Supervisor"><a href="#Supervisor" class="headerlink" title="Supervisor"></a>Supervisor</h2><h2 id="Shipyard"><a href="#Shipyard" class="headerlink" title="Shipyard"></a>Shipyard</h2><h2 id="DockerUI"><a href="#DockerUI" class="headerlink" title="DockerUI"></a>DockerUI</h2><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://dockerpool.com/static/books/docker_practice/index.html" target="_blank" rel="noopener">Docker入门到实践</a></p>
<p><a href="http://www.widuu.com/chinese_docker/" target="_blank" rel="noopener">Docker中文指南</a></p>
<p><a href="http://www.docker.com/" target="_blank" rel="noopener">Docker官网</a></p>
<p><a href="http://www.dockerone.com/" target="_blank" rel="noopener">Docker交流网站</a></p>
<p><a href="http://en.wikipedia.org/wiki/UnionFS" target="_blank" rel="noopener">UnionFS</a></p>
<p><a href="http://www.91ri.org/7527.html" target="_blank" rel="noopener">dionaea低交互式蜜罐和记录分析</a></p>
<p><a href="http://www.91ri.org/12248.html" target="_blank" rel="noopener">蜜罐快速搭建</a></p>
<p><a href="http://drops.wooyun.org/wp-content/uploads/2015/01/dionaeaui.zip" target="_blank" rel="noopener">Dockefile文件下载</a></p>
<p><a href="http://dockone.io/article/128" target="_blank" rel="noopener">深入了解Docker Volume</a></p>
<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>菜鸡还不具备创造能力，部分学习内容来自网络，回馈网络，如涉及版权问题，请联系删除  orz </p>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="https://passenger-amao.github.io">AMao</a></p><p> <span>Link:  </span><a href="https://passenger-amao.github.io/2020/04/30/Docker/">https://passenger-amao.github.io/2020/04/30/Docker/</a></p><p> <span>Copyright:  </span><span>本站所有文章均采用 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">署名-非商业性使用-相同方式共享 4.0 国际(CC BY-NC-SA 4.0)</a> 许可协议。转载请注明出处！</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2020/05/10/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" title="2019湖湘杯WP-Web"><span>< PreviousPost</span><br><span class="prevTitle">2019湖湘杯WP-Web</span></a><a class="nextSlogan" href="/2020/02/25/Linux-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" title="Linux 快速入门"><span>NextPost ></span><br><span class="nextTitle">Linux 快速入门</span></a><div class="clear"></div></div><div id="comment"></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span> | theme </span><a href="https://github.com/Longlongyu/hexo-theme-Cxo" target="_blank" rel="noopener"><span>Cxo</span></a></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 70vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基础"><span class="toc-number">1.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述"><span class="toc-number">1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优点"><span class="toc-number">1.2.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#相关概念"><span class="toc-number">1.3.</span> <span class="toc-text">相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#镜像（Image）"><span class="toc-number">1.3.1.</span> <span class="toc-text">镜像（Image）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#容器（Container）"><span class="toc-number">1.3.2.</span> <span class="toc-text">容器（Container）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#容器（Container）-1"><span class="toc-number">1.3.3.</span> <span class="toc-text">容器（Container）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#仓库（Repository）"><span class="toc-number">1.3.4.</span> <span class="toc-text">仓库（Repository）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker和虚拟机的区别"><span class="toc-number">1.4.</span> <span class="toc-text">Docker和虚拟机的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#虚拟机架构"><span class="toc-number">1.4.1.</span> <span class="toc-text">虚拟机架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#容器的架构"><span class="toc-number">1.4.2.</span> <span class="toc-text">容器的架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LXC"><span class="toc-number">1.4.3.</span> <span class="toc-text">LXC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker和Microservices"><span class="toc-number">1.4.4.</span> <span class="toc-text">Docker和Microservices</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优势"><span class="toc-number">1.4.5.</span> <span class="toc-text">优势</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#创建镜像"><span class="toc-number">2.</span> <span class="toc-text">创建镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#修改已有的镜像"><span class="toc-number">2.1.</span> <span class="toc-text">修改已有的镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用Dockerfile创建镜像"><span class="toc-number">2.2.</span> <span class="toc-text">利用Dockerfile创建镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Dockerfile"><span class="toc-number">2.2.1.</span> <span class="toc-text">Dockerfile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dockerfile-创建镜像"><span class="toc-number">2.2.2.</span> <span class="toc-text">Dockerfile 创建镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#镜像构建上下文"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">镜像构建上下文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dockerfile-文件命名"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">Dockerfile 文件命名</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#镜像操作"><span class="toc-number">2.3.</span> <span class="toc-text">镜像操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#查看"><span class="toc-number">2.3.1.</span> <span class="toc-text">查看</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#导入"><span class="toc-number">2.3.2.</span> <span class="toc-text">导入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#导出"><span class="toc-number">2.3.3.</span> <span class="toc-text">导出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除本地镜像"><span class="toc-number">2.3.4.</span> <span class="toc-text">删除本地镜像</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用镜像创建容器"><span class="toc-number">3.</span> <span class="toc-text">使用镜像创建容器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#容器管理"><span class="toc-number">4.</span> <span class="toc-text">容器管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#查看输出信息"><span class="toc-number">4.0.1.</span> <span class="toc-text">查看输出信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进入"><span class="toc-number">4.0.2.</span> <span class="toc-text">进入</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#容器与主机之间的文件操作"><span class="toc-number">5.</span> <span class="toc-text">容器与主机之间的文件操作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker-Compose"><span class="toc-number">6.</span> <span class="toc-text">Docker Compose</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#yml-配置指令参考"><span class="toc-number">6.1.</span> <span class="toc-text">yml 配置指令参考</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数据管理"><span class="toc-number">7.</span> <span class="toc-text">数据管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据卷（Data-volumes）"><span class="toc-number">7.0.1.</span> <span class="toc-text">数据卷（Data volumes）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据卷容器（Data-volume-containers）"><span class="toc-number">7.0.2.</span> <span class="toc-text">数据卷容器（Data volume containers）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据卷的操作"><span class="toc-number">7.1.</span> <span class="toc-text">数据卷的操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据卷容器"><span class="toc-number">7.2.</span> <span class="toc-text">数据卷容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建"><span class="toc-number">7.2.1.</span> <span class="toc-text">创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据迁移"><span class="toc-number">7.2.2.</span> <span class="toc-text">数据迁移</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#网络使用"><span class="toc-number">8.</span> <span class="toc-text">网络使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#外部访问容器"><span class="toc-number">8.1.</span> <span class="toc-text">外部访问容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#容器互联"><span class="toc-number">8.1.1.</span> <span class="toc-text">容器互联</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#管理工具"><span class="toc-number">9.</span> <span class="toc-text">管理工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Supervisor"><span class="toc-number">9.1.</span> <span class="toc-text">Supervisor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shipyard"><span class="toc-number">9.2.</span> <span class="toc-text">Shipyard</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DockerUI"><span class="toc-number">9.3.</span> <span class="toc-text">DockerUI</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料"><span class="toc-number">10.</span> <span class="toc-text">参考资料</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#声明"><span class="toc-number">11.</span> <span class="toc-text">声明</span></a></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>